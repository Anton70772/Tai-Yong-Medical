"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// runtime/src/index.ts
var src_exports = {};
__export(src_exports, {
  $$: () => $$,
  init: () => init,
  registerMetadata: () => registerMetadata,
  reset: () => reset,
  useCapture: () => useCapture
});
module.exports = __toCommonJS(src_exports);

// runtime/src/core/index.ts
var React2 = __toESM(require("react"));

// runtime/src/core/utils/constants.ts
var _null = null;
var isSSR = typeof window === "undefined";
var _window = isSSR ? _null : window;
var _Map = Map;
var _Object = Object;
var _Array = Array;
var _isArray = _Array.isArray;
var _setTimeout = setTimeout;
var _performance = performance;
var _Function = Function;
var functionProto = _Function.prototype;
var mapProto = _Map.prototype;
var _mapHas = mapProto.has;
var _mapGet = mapProto.get;
var _mapSet = mapProto.set;
var objectPrototype = _Object.prototype;
var _objectHasOwnProperty = objectPrototype.hasOwnProperty;
var _objectToString = objectPrototype.toString;
var UNKNOWN = "<unknown>";
var VERSION = "1.0.0-rc.12";
var FLAG = "_ANYA_";
var MAX_QUEUE_SIZE = 1e4;
var FLUSH_TIMEOUT = false ? 5e3 : 1e3;
var SESSION_EXPIRE_TIMEOUT = FLUSH_TIMEOUT * 60;
var GZIP_MIN_LEN = 1e3;
var ENDPOINT = "https://lint.million.dev/api/v1/ingest";
var REACT_PREFIX = "Symbol(react.";
var ELEMENT_SYMBOL_STRING = REACT_PREFIX + "element)";
var FORWARD_REF_SYMBOL_STRING = REACT_PREFIX + "forward_ref)";
var LAZY_SYMBOL_STRING = REACT_PREFIX + "lazy)";
var MEMO_SYMBOL_STRING = REACT_PREFIX + "memo)";
var FRAGMENT_SYMBOL_STRING = REACT_PREFIX + "fragment)";
var PORTAL_SYMBOL_STRING = REACT_PREFIX + "portal)";
var PROFILER_SYMBOL_STRING = REACT_PREFIX + "profiler)";
var STRICT_MODE_SYMBOL_STRING = REACT_PREFIX + "strict_mode)";
var SUSPENSE_SYMBOL_STRING = REACT_PREFIX + "suspense)";
var SUSPENSE_LIST_SYMBOL_STRING = REACT_PREFIX + "suspense_list)";
var MOBX_SYMBOL_STRING = "Symbol(mobx administration)";
var PROFILER_DISPLAY_NAME = "Million(Profiler)";
var VOID_ELEMENTS = [
  "area",
  "base",
  "br",
  "col",
  "embed",
  "hr",
  "img",
  "input",
  "keygen",
  "link",
  "menuitem",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
];

// runtime/src/core/utils/helpers.ts
var debounce = (callback, timeout = 1e3) => {
  let timeoutId;
  return function() {
    if (timeoutId != _null) {
      clearTimeout(timeoutId);
    }
    timeoutId = _setTimeout(() => {
      callback.apply(null, arguments);
      timeoutId = void 0;
    }, timeout);
  };
};
var onIdle = (callback) => {
  if ("scheduler" in globalThis) {
    return _window.scheduler.postTask(callback, { priority: "background" });
  }
  if ("requestIdleCallback" in _window) {
    return requestIdleCallback(callback);
  }
  return _setTimeout(callback, 0);
};
var onHidden = (callback) => {
  const handler = (event) => {
    if (event.type === "pagehide" || document.visibilityState === "hidden") {
      callback();
    }
  };
  addEventListener("visibilitychange", handler, true);
  addEventListener("pagehide", handler, true);
};
var generateId = () => {
  return Math.random().toString(36).substring(2) + Date.now();
};
var getRenderBatchIndexKey = (key, kind, loc, owner2, error) => {
  return (
    // eslint-disable-next-line prefer-template
    key + "." + kind + "." + loc + "." + (owner2 || "") + "." + (error || "")
  );
};

// runtime/src/core/session.ts
var getGpuRenderer = () => {
  if (!("chrome" in _window))
    return "";
  const gl = document.createElement("canvas").getContext("webgl", { powerPreference: "high-performance" });
  if (!gl)
    return "";
  const ext = gl.getExtension("WEBGL_debug_renderer_info");
  return ext ? gl.getParameter(ext.UNMASKED_RENDERER_WEBGL) : "";
};
var getSession = () => {
  if (isSSR)
    return _null;
  const id = generateId();
  const url2 = _window.location.toString();
  const wifi = navigator.connection?.effectiveType || UNKNOWN;
  const cpu = navigator.hardwareConcurrency;
  const mem = navigator.deviceMemory;
  const session2 = {
    id,
    url: url2,
    wifi,
    cpu,
    mem,
    gpu: UNKNOWN
  };
  onIdle(() => {
    session2.gpu = getGpuRenderer();
  });
  return session2;
};

// runtime/src/core/transport.ts
var contentType = "application/json";
var supportsCompression = typeof CompressionStream === "function";
var compress = async (payload) => {
  const stream = new Blob([payload], { type: contentType }).stream().pipeThrough(new CompressionStream("gzip"));
  return new Response(stream).arrayBuffer();
};
var transport = async (url2, payload) => {
  const fail = { ok: false };
  if (isSSR)
    return fail;
  const json = JSON.stringify(payload, (key, value) => {
    if (
      // eslint-disable-next-line eqeqeq
      value != null && value !== false && // eslint-disable-next-line @typescript-eslint/prefer-string-starts-ends-with
      key[0] !== "_"
    ) {
      if (false) {
        if (typeof value === "number") {
          return ~~value;
        }
      }
      return value;
    }
  });
  const shouldCompress = json.length > GZIP_MIN_LEN;
  const body = shouldCompress && supportsCompression ? await compress(json) : json;
  let prod;
  if (prod = false) {
    if (!navigator.onLine)
      return fail;
  }
  const headers = {
    "Content-Type": contentType,
    "Content-Encoding": shouldCompress ? "gzip" : void 0
  };
  if (shouldCompress)
    url2 += "?z=1";
  return fetch(url2, {
    body,
    method: "POST",
    // make sure payload actually gets thru
    keepalive: true,
    priority: "low",
    mode: prod ? void 0 : "no-cors",
    headers
  });
};

// runtime/src/core/utils/internals.ts
var React = __toESM(require("react"));
function useFiber() {
  const fiber = React.useRef();
  React.useState(() => {
    const bind = functionProto.bind;
    functionProto.bind = function(self, maybeFiber) {
      if (self === _null && typeof maybeFiber?.type === "function") {
        fiber.current = maybeFiber;
        functionProto.bind = bind;
      }
      return bind.apply(this, arguments);
    };
  });
  return fiber.current;
}
var traverseFiber = (fiber, ascending, selector) => {
  if (!fiber)
    return _null;
  if (selector(fiber) === true)
    return fiber;
  let child = ascending ? fiber.return : fiber.child;
  while (child) {
    const match = traverseFiber(child, ascending, selector);
    if (match)
      return match;
    child = ascending ? null : child.sibling;
  }
  return _null;
};
var useNearestChild = (fiber) => {
  const childRef = React.useRef();
  React.useLayoutEffect(() => {
    childRef.current = traverseFiber(
      fiber,
      false,
      (node) => typeof node.type === "string"
    )?.stateNode;
  }, [fiber]);
  return childRef;
};
var didFiberRender = (fiber) => {
  if (!fiber?.alternate)
    return true;
  const { alternate } = fiber;
  return alternate.memoizedProps !== fiber.memoizedProps || alternate.memoizedState !== fiber.memoizedState || alternate.ref !== fiber.ref;
};
var getTimings = (fiber) => {
  const totalTime = fiber?.actualDuration ?? 0;
  let selfTime = totalTime;
  let child = fiber?.child;
  while (totalTime > 0 && child != _null) {
    selfTime -= child?.actualDuration || 0;
    child = child.sibling;
  }
  return {
    /**
     * totalTime
     */
    t: totalTime,
    /**
     * selfTime
     */
    s: selfTime
  };
};
var owner = _null;
var getCurrentOwner = (fiber) => {
  let currentOwner = owner;
  if (!fiber) {
    currentOwner = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED?.ReactCurrentOwner.current;
  }
  if (currentOwner)
    owner = currentOwner;
  return owner;
};
var getParentOwner = (fiber) => {
  const type = getCurrentOwner(fiber)?._debugOwner?.type;
  if (!type || typeof type !== "function")
    return _null;
  return type[FLAG] || _null;
};
var truncateString = (value, length) => {
  return value.length > length ? value.slice(0, length) + "\u2026" : value;
};
var serialize = (value) => {
  switch (typeof value) {
    case "function":
      return truncateString(value.toString(), 20);
    case "string":
      return truncateString(value, 20);
    case "object":
      if (value === _null) {
        return "null";
      }
      if (_Array.isArray(value)) {
        return value.length > 0 ? "[\u2026]" : "[]";
      }
      if (typeof value.$$typeof === "symbol" && String(value.$$typeof) === ELEMENT_SYMBOL_STRING) {
        return (
          // eslint-disable-next-line prefer-template
          "<" + (value.type.displayName || value.type.name || "") + (_Object.keys(value.props).length > 0 ? " \u2026" : "") + ">"
        );
      }
      if (typeof value === "object" && value !== _null && value.constructor === _Object) {
        for (const key in value) {
          if (_objectHasOwnProperty.call(value, key)) {
            return "{\u2026}";
          }
        }
        return "{}";
      }
      const tagString = _objectToString.call(value).slice(8, -1);
      if (tagString === "Object") {
        const constructor = _Object.getPrototypeOf(value)?.constructor;
        if (typeof constructor === "function") {
          return (constructor.displayName || constructor.name || "") + "{\u2026}";
        }
      }
      return tagString + "{\u2026}";
    default:
      return String(value);
  }
};
var getFunctionFromJSX = (element, isStyledComponent = false) => {
  if (typeof element === "function")
    return element;
  if (typeof element !== "object")
    return _null;
  const type = isStyledComponent ? element.type.target : element.type;
  if (typeof type === "function")
    return type;
  if (typeof type !== "object")
    return _null;
  if ("$$typeof" in type) {
    switch (String(type.$$typeof)) {
      case FORWARD_REF_SYMBOL_STRING:
        return getFunctionFromJSX(element.type.render, false);
      case MEMO_SYMBOL_STRING:
      case LAZY_SYMBOL_STRING:
        return getFunctionFromJSX(element.type, false);
    }
  }
  return _null;
};
var setRef = (ref, value) => {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref !== null && ref !== void 0) {
    ref.current = value;
  }
};
var mergeProps = (nextProps, prevProps) => {
  const overrideProps = _Object.assign({}, nextProps);
  for (const propName in nextProps) {
    const nextPropValue = nextProps[propName];
    const prevPropValue = prevProps[propName];
    if (propName.startsWith("on")) {
      if (nextPropValue && prevPropValue) {
        overrideProps[propName] = function() {
          prevPropValue.apply(this, arguments);
          nextPropValue.apply(this, arguments);
        };
      } else if (nextPropValue) {
        overrideProps[propName] = nextPropValue;
      }
    } else if (propName === "style") {
      overrideProps[propName] = _Object.assign(
        {},
        prevPropValue,
        nextPropValue
      );
    } else if (propName === "className") {
      overrideProps[propName] = [nextPropValue, prevPropValue].filter(Boolean).join(" ");
    }
  }
  return _Object.assign({}, prevProps, overrideProps);
};
var types = [
  STRICT_MODE_SYMBOL_STRING,
  FRAGMENT_SYMBOL_STRING,
  PROFILER_SYMBOL_STRING,
  SUSPENSE_SYMBOL_STRING,
  SUSPENSE_LIST_SYMBOL_STRING
];
var isSpecialElement = (element) => {
  return (
    // is class
    typeof element.type === "function" && element.type.prototype?.isReactComponent || String(element.$$typeof) === PORTAL_SYMBOL_STRING || types.includes(String(element.type)) || // some components for @mui/material
    element.render?.muiName
  );
};
var isMobXLoaded = Symbol.for("mobx administration");
var isMobXStore = (value) => {
  if (!isMobXLoaded || !value || typeof value !== "object") {
    return false;
  }
  const symbol = _Object.getOwnPropertySymbols(value)[0];
  return String(symbol) === MOBX_SYMBOL_STRING;
};

// runtime/src/core/index.ts
var IS_REACT_19 = React2.version.startsWith("19");
var batchIndexLookup = /* @__PURE__ */ new _Map();
var metadataLookup = /* @__PURE__ */ new _Map();
var batch = [];
var inited = false;
var session = /* @__PURE__ */ getSession();
var url = _null;
var apiKey;
var buildId;
var onRender = _null;
var interactions = [];
var currentId = _null;
var currentIndex = -1;
var bytes = 0;
var items = 0;
var getMetadata = (key) => {
  return _mapGet.call(metadataLookup, key);
};
var UNSTABLE_TYPES = ["object", "function"];
var getChange = (prevValue, nextValue) => {
  if (_Object.is(prevValue, nextValue))
    return _null;
  const prev = serialize(prevValue);
  const next = serialize(nextValue);
  const type = nextValue ? typeof nextValue : typeof prevValue;
  const unstable = prev === next && UNSTABLE_TYPES.includes(type);
  return {
    // unstable
    u: unstable,
    // type
    t: type,
    // count
    c: 1,
    // index: (if it's a change of the deps array, this will be the index of the dep)
    i: _null,
    // name: used to help identify the change
    // prop change postfixes this with the name of the prop
    // âŸ = "unit seperator symbol"
    // eslint-disable-next-line prefer-template
    n: prev === next ? prev : prev + "~" + next,
    d: _null
  };
};
var captureClass = (key, setState, loc, index, noisy, cache) => {
  return function() {
    const value = arguments[0];
    const fiber = useFiber();
    if (noisy)
      return value;
    const owner2 = getParentOwner(fiber);
    const prevValue = cache?.[index];
    setState.apply(this, arguments);
    const change = getChange(prevValue, value);
    if (change) {
      reportRender(
        // key: encode(filename).encoded(componentName)
        // (e.g. "/some/file/path/index.jsx.App")
        key,
        4 /* Value */,
        // CaptureKind
        // loc: encode(SourceLocation)
        // e.g. `this.setState(newVal)` -> encode([1, 2, 3, 4])
        loc,
        _null,
        // secondaryLoc
        _null,
        // locs
        0,
        // selfTime
        0,
        // totalTime
        1,
        // count
        _null,
        // self
        owner2,
        // owner
        _null,
        // message
        [change]
        // changes
      );
      if (cache)
        cache[index] = value;
    }
    return value;
  };
};
var captureDeps = (key, deps, loc, locs, index, noisy, cache) => {
  if (!_isArray(deps))
    return deps;
  const fiber = useFiber();
  if (noisy)
    return deps;
  const owner2 = getParentOwner(fiber);
  const prev = cache?.[index];
  const changes = [];
  if (prev) {
    for (let i = 0, len = deps.length; i < len; i++) {
      const prevDepValue = prev[i];
      const nextDepValue = deps[i];
      const change = getChange(prevDepValue, nextDepValue);
      if (!change)
        continue;
      change.n = `${i}`;
      changes.push(change);
    }
  }
  if (!prev || changes.length) {
    reportRender(
      // key: encode(filename).encoded(componentName)
      // (e.g. "/some/file/path/index.jsx.App")
      key,
      1 /* Deps */,
      // CaptureKind
      // loc: encode(SourceLocation)
      // e.g. `[foo, bar, baz]` -> encode([1, 2, 3, 4])
      loc,
      _null,
      // secondaryLoc
      // locs: encode([Dep1SourceLocation, Dep2SourceLocation, ...])
      // e.g. `[foo, bar, baz]` -> encode([[1, 2, 3, 4], [5, 6, 7, 8], ...])
      locs,
      0,
      // selfTime
      0,
      // totalTime
      1,
      // count
      _null,
      // self
      owner2,
      // owner
      _null,
      // message
      changes
      // changes
    );
  }
  if (cache)
    cache[index] = deps;
  return deps;
};
var captureProps = (key, props, loc, index, noisy, cache) => {
  if (typeof props !== "object")
    return props;
  const fiber = useFiber();
  const owner2 = getParentOwner(fiber);
  if (noisy)
    return props;
  const prev = cache?.[index];
  if (didFiberRender(fiber)) {
    const changes = [];
    if (prev) {
      for (const name in props) {
        const change = getChange(prev[name], props[name]);
        if (!change)
          continue;
        change.n = name;
        changes.push(change);
      }
    }
    if (!prev || changes.length) {
      reportRender(
        // key: encode(filename).encoded(componentName)
        // e.g. "/some/file/path/index.jsx.App"
        key,
        2 /* Props */,
        // CaptureKind
        loc,
        // loc: encode(SourceLocation)
        _null,
        // secondaryLoc
        _null,
        // locs
        0,
        // selfTime
        0,
        // totalTime
        1,
        // count
        _null,
        // self
        owner2,
        // owner
        _null,
        // message
        changes
        // changes
      );
    }
  }
  if (!prev) {
    for (const name in props) {
      if (name === "children")
        continue;
      if (isMobXStore(props[name])) {
        reportRender(
          // key: encode(filename).encoded(componentName)
          // e.g. "/some/file/path/index.jsx.App"
          key,
          // JSXMount = 'mount' | 'unmount'
          // JSXUpdate = 'update'
          1024 /* Note */,
          // CaptureKind
          // loc = scoped source location of the JSX element,
          // or the location of the JSX element
          loc,
          _null,
          // secondaryLoc = location of the JSX element
          _null,
          // locs
          0,
          // selfTime
          0,
          // totalTime
          0,
          // count
          _null,
          // self
          owner2,
          // owner
          "mobx store",
          // message
          []
          // changes
        );
      }
    }
  }
  if (cache)
    cache[index] = props;
  return props;
};
var captureValue = (key, value, loc, index, noisy, cache) => {
  const fiber = useFiber();
  if (noisy)
    return value;
  const owner2 = getParentOwner(fiber);
  if (fiber && _isArray(value) && value.length === 2 && typeof value[1] === "function") {
    const dispatcher = value[1];
    if (cache) {
      if (!cache[index]) {
        reportRender(
          // key: encode(filename).encoded(componentName)
          // e.g. "/some/file/path/index.jsx.App"
          key,
          4 /* Value */,
          // CaptureKind
          loc,
          // loc: encode(SourceLocation)
          _null,
          // secondaryLoc
          _null,
          // locs
          0,
          // selfTime
          0,
          // totalTime
          1,
          // count
          _null,
          // self
          owner2,
          // owner
          _null,
          // message
          []
          // changes
        );
      }
      cache[index] = value[0];
    }
    value[1] = function(nextValue) {
      const prevValue2 = value[0];
      dispatcher(nextValue);
      const change = getChange(prevValue2, nextValue);
      if (!change || !didFiberRender(fiber))
        return;
      const {
        s,
        t
        /* totalTime */
      } = getTimings(fiber);
      reportRender(
        // key: encode(filename).encoded(componentName)
        // e.g. "/some/file/path/index.jsx.App"
        key,
        4 /* Value */,
        // CaptureKind
        loc,
        // loc: encode(SourceLocation)
        _null,
        // secondaryLoc
        _null,
        // locs
        s,
        // selfTime
        t,
        // totalTime
        1,
        // count
        _null,
        // self
        owner2,
        // owner
        _null,
        // message
        [change]
        // changes
      );
    };
    return value;
  }
  let targetValue = value;
  if (fiber && typeof value === "object" && value?.current) {
    targetValue = value.current;
  }
  const prevValue = cache?.[index];
  if (didFiberRender(fiber)) {
    const change = getChange(prevValue, targetValue);
    if (!change)
      return value;
    reportRender(
      // key: encode(filename).encoded(componentName)
      // e.g. "/some/file/path/index.jsx.App"
      key,
      // CaptureKind
      4 /* Value */,
      // loc: encode(SourceLocation)
      loc,
      // loc: encode(SourceLocation)
      _null,
      // secondaryLoc
      _null,
      // locs
      0,
      // selfTime
      0,
      // totalTime
      1,
      // count
      _null,
      // self
      owner2,
      // owner
      _null,
      // message
      [change]
      // changes
    );
  }
  if (cache)
    cache[index] = targetValue;
  return value;
};
var captureFunction = (key, fn, loc, noisy) => {
  if (typeof fn !== "function" || FLAG in fn || noisy)
    return fn;
  const capturedFn = function() {
    const startTime = _performance.now();
    try {
      const maybeEvent = arguments[0];
      if (maybeEvent && typeof maybeEvent === "object" && maybeEvent.currentTarget && typeof maybeEvent.currentTarget === "object") {
        maybeEvent.currentTarget[FLAG] = key + "." + loc;
      }
      const ret = fn.apply(this, arguments);
      const time = _performance.now() - startTime;
      reportRender(
        // key: encode(filename).encoded(componentName)
        // e.g. "/some/file/path/index.jsx.App"
        key,
        128 /* Function */,
        loc,
        // loc
        null,
        // secondaryLoc
        _null,
        // locs
        time,
        // selfTime
        time,
        // totalTime
        1,
        // count
        null,
        // self
        null,
        // owner
        null,
        // message
        []
        // changes
      );
      return ret;
    } catch (error) {
      reportRender(
        // key: encode(filename).encoded(componentName)
        // e.g. "/some/file/path/index.jsx.App"
        key,
        256 /* Error */,
        loc,
        // loc
        null,
        // secondaryLoc
        _null,
        // locs
        0,
        // selfTime
        0,
        // totalTime
        1,
        // count
        null,
        // self
        null,
        // owner
        error.message.trim(),
        // message
        []
        // changes
      );
      throw error;
    }
  };
  capturedFn[FLAG] = true;
  return capturedFn;
};
var Slot = /* @__PURE__ */ React2.forwardRef(
  (props, forwardedRef) => {
    const element = props._l;
    if (!element)
      return element;
    if (React2.isValidElement(element)) {
      if (typeof element.type === "string" && VOID_ELEMENTS.includes(element.type)) {
        return element;
      }
      const originalRef = IS_REACT_19 ? element.props.ref : element.ref;
      let ref = originalRef;
      if (forwardedRef) {
        ref = (value) => {
          setRef(originalRef, value);
          setRef(forwardedRef, value);
        };
      }
      const newProps = _Object.assign(
        mergeProps(element.props, props),
        {
          ref
        }
      );
      newProps._l = void 0;
      newProps._c = void 0;
      newProps._p = void 0;
      return /* @__PURE__ */ React2.cloneElement(
        props._p,
        _null,
        React2.cloneElement(
          element,
          newProps,
          props._c || props.children || element.props?.children
        )
      );
    }
    return element;
  }
);
Slot.displayName = PROFILER_DISPLAY_NAME;
var Profiler2 = React2.Profiler;
var renderInnerProfiler = (element, id, timeQueue) => {
  if (element.type.displayName === PROFILER_DISPLAY_NAME)
    return element;
  const profiler = React2.createElement(Profiler2, {
    id,
    onRender: (_id, _phase, totalTime) => {
      timeQueue.push(totalTime);
    },
    suppressHydrationWarning: true,
    children: element
  });
  if (String(element.type?.$$typeof) !== FORWARD_REF_SYMBOL_STRING) {
    return profiler;
  }
  return /* @__PURE__ */ React2.createElement(Slot, {
    _l: element,
    _c: void 0,
    _p: profiler
  });
};
var captureJSX = (key, element, loc, secondaryLoc, index, profilerType, noisy, cache) => {
  if (isSpecialElement(element) || noisy)
    return element;
  let isStyledComponent = false;
  if (typeof element.type === "object" && element.type?.componentStyle) {
    isStyledComponent = true;
    if (typeof element.type?.target === "string")
      return element;
  }
  const reference = getFunctionFromJSX(element, isStyledComponent);
  const self = reference?.[FLAG];
  const owner2 = getParentOwner(_null);
  let changes = [];
  const props = element.props;
  if (reference?.name === "observerComponent") {
    reportRender(
      // key: encode(filename).encoded(componentName)
      // e.g. "/some/file/path/index.jsx.App"
      key,
      // JSXMount = 'mount' | 'unmount'
      // JSXUpdate = 'update'
      1024 /* Note */,
      // CaptureKind
      // loc = scoped source location of the JSX element,
      // or the location of the JSX element
      loc,
      secondaryLoc,
      // secondaryLoc = location of the JSX element
      _null,
      // locs
      0,
      // selfTime
      0,
      // totalTime
      0,
      // count
      self,
      // self
      owner2,
      // owner
      "mobx observer",
      // message
      changes
      // changes
    );
  }
  const prev = cache?.[index];
  if (prev) {
    for (const name in props) {
      if (name === "children")
        continue;
      const change = getChange(prev[name], props[name]);
      if (!change)
        continue;
      change.n = name;
      changes.push(change);
    }
  }
  if (cache)
    cache[index] = props;
  const timeQueue = [];
  const children = element.props.children;
  const existingKey = element.key || void 0;
  const hasProfilerType = profilerType != _null;
  const outerProfiler = React2.createElement(Profiler2, {
    id: key,
    key: existingKey,
    onRender: (_id, phase, totalTime) => {
      if (phase === "nested-update")
        return;
      const currentTime = timeQueue.shift() || 0;
      reportRender(
        // key: encode(filename).encoded(componentName)
        // e.g. "/some/file/path/index.jsx.App"
        key,
        // JSXMount = 'mount' | 'unmount'
        // JSXUpdate = 'update'
        phase === "update" ? 64 /* JSXUpdate */ : 32 /* JSXMount */,
        // loc = scoped source location of the JSX element,
        // or the location of the JSX element
        loc,
        secondaryLoc,
        // secondaryLoc = location of the JSX element
        _null,
        // locs
        currentTime <= totalTime ? totalTime - currentTime : 0,
        // selfTime
        totalTime,
        // totalTime
        1,
        // count
        self,
        // self
        owner2,
        // owner
        _null,
        // message
        changes
        // changes
      );
      changes = [];
    },
    suppressHydrationWarning: true,
    children: IS_REACT_19 ? element : hasProfilerType ? profilerType & 0 /* NoRef */ && children ? renderInnerProfiler(children, key, timeQueue) : element : _null
  });
  if (hasProfilerType || IS_REACT_19) {
    return outerProfiler;
  }
  return /* @__PURE__ */ React2.createElement(Slot, {
    key: existingKey,
    _l: element,
    _c: React2.isValidElement(children) ? renderInnerProfiler(children, key, timeQueue) : children,
    _p: outerProfiler
  });
};
var componentIds = /* @__PURE__ */ new WeakMap();
var captureMount = (key, data, loc) => {
  let noisy = false;
  const fiber = useFiber();
  const child = useNearestChild(fiber);
  if (fiber?.updateQueue?.memoCache) {
    data.$ = true;
  }
  const current = child?.current;
  if (current && !(FLAG in current)) {
    current[FLAG] = key;
  }
  if (true) {
    const ref = React2.useRef(_null);
    if (ref.current === _null) {
      const owner2 = getCurrentOwner(fiber);
      ref.current = true;
      if (owner2) {
        const prevMemoizedState = componentIds.get(owner2);
        if (!componentIds.has(owner2)) {
          componentIds.set(owner2, owner2.memoizedState);
        } else if (owner2.memoizedState !== prevMemoizedState) {
          componentIds.delete(owner2);
          noisy = true;
        }
      }
    }
  }
  const {
    s,
    t
    /* totalTime */
  } = getTimings(fiber);
  React2.useEffect(() => {
    if (didFiberRender(fiber) && !noisy) {
      reportRender(
        // key: encode(filename).encoded(componentName)
        // e.g. "/some/file/path/index.jsx.App"
        key,
        512 /* Baseline */,
        loc,
        // loc
        _null,
        // secondaryLoc
        _null,
        // locs
        s,
        // selfTime
        t,
        // totalTime
        1,
        // count
        _null,
        // self
        _null,
        // owner
        _null,
        // message
        []
        // changes
      );
    }
  });
  React2.useEffect(() => {
    noisy = false;
    data.i++;
    return () => {
      data.i--;
    };
  }, []);
  return {
    n: noisy,
    c: React2.useState(() => new _Array(data.c))[0]
  };
};
var $$ = (kind, key, value, loc, secondaryLoc, locs, index, profilerType, mountInfo) => {
  if (isSSR)
    return value;
  const data = getMetadata(key);
  if (!data)
    return value;
  const noisy = mountInfo?.n || false;
  const cache = mountInfo?.c || _null;
  if (kind & 512 /* Baseline */) {
    return captureMount(key, data, loc);
  } else if (kind & 2 /* Props */) {
    return captureProps(key, value, loc, index, noisy, cache);
  } else if (kind & 4 /* Value */) {
    return captureValue(key, value, loc, index, noisy, cache);
  } else if (kind & 1 /* Deps */) {
    return captureDeps(key, value, loc, locs, index, noisy, cache);
  } else if (kind & 16 /* JSX */) {
    return captureJSX(
      key,
      value,
      loc,
      secondaryLoc,
      index,
      profilerType,
      noisy,
      cache
    );
  } else if (kind & 128 /* Function */) {
    return captureFunction(key, value, loc, noisy);
  } else if (kind & 256 /* Error */) {
  } else if (kind & 0 /* ClassSetState */) {
    return captureClass(key, value, loc, index, noisy, cache);
  }
  return value;
};
var useCapture = (value, key, loc, index, mountInfo) => {
  if (!key || loc == _null || index == _null || value == _null || mountInfo == _null) {
    return value;
  }
  return $$(
    typeof value === "object" && "$$typeof" in value ? 16 /* JSX */ : 4 /* Value */,
    key,
    // key
    value,
    // value
    loc,
    // loc
    _null,
    // secondaryLoc
    _null,
    // locs
    index,
    // index
    _null,
    // profilerType
    mountInfo || _null
    // mountInfo
  );
};
var mergeChange = (prev, next) => {
  if (!prev && !next)
    return [];
  if (!prev?.length)
    return next;
  if (!next?.length)
    return prev;
  let prevHead = 0;
  let nextHead = 0;
  let prevTail = prev.length - 1;
  let nextTail = next.length - 1;
  while (prevHead <= prevTail && nextHead <= nextTail) {
    const prevHeadChange = prev[prevHead];
    const nextHeadChange = next[nextHead];
    const prevTailChange = prev[prevTail];
    const nextTailChange = next[nextTail];
    if (prevHeadChange.n === nextHeadChange.n) {
      prevHeadChange.c += nextHeadChange.c;
      if (!prevHeadChange.u) {
        prevHeadChange.u = nextHeadChange.u;
      }
      prevHead++;
      nextHead++;
    } else if (prevTailChange.n === nextTailChange.n) {
      prevTailChange.c += nextTailChange.c;
      if (!prevTailChange.u) {
        prevTailChange.u = nextTailChange.u;
      }
      prevTail--;
      nextTail--;
    } else {
      break;
    }
  }
  const changeIndexLookup = new _Map();
  for (; prevHead <= prevTail; prevHead++) {
    _mapSet.call(changeIndexLookup, prev[prevHead].n, prevHead);
  }
  for (; nextHead <= nextTail; nextHead++) {
    const nextChange = next[nextHead];
    const head = _mapGet.call(changeIndexLookup, nextChange.n);
    if (head == _null) {
      const index = prev.push(nextChange);
      _mapSet.call(changeIndexLookup, nextChange.n, index - 1);
      continue;
    }
    const prevChange = prev[head];
    prevChange.c += nextChange.c;
    if (!prevChange.u) {
      prevChange.u = nextChange.u;
    }
  }
  return prev;
};
var reportRender = (key, kind, loc, secondaryLoc, locs, selfTime, totalTime, count, self, owner2, message, changes) => {
  const render = {
    k: kind,
    l: loc,
    l2: secondaryLoc,
    ls: locs,
    s: selfTime,
    t: totalTime,
    c: count,
    i: self,
    o: owner2,
    m: message,
    d: changes,
    x: currentIndex
  };
  const batchKey = getRenderBatchIndexKey(key, kind, loc, owner2, message);
  if (_mapHas.call(batchIndexLookup, batchKey)) {
    const prevIndex = _mapGet.call(batchIndexLookup, batchKey);
    const prevRender = batch[prevIndex].r;
    prevRender.c += count;
    prevRender.t += totalTime;
    prevRender.s += selfTime;
    prevRender.d = mergeChange(prevRender.d, changes);
    return;
  }
  _mapSet.call(batchIndexLookup, batchKey, batch.length);
  const renderItem = {
    k: key,
    r: render
  };
  if (batch.length >= MAX_QUEUE_SIZE) {
    flush();
    return;
  }
  batch.push(renderItem);
  onRender?.();
};
var flush = () => {
  const renderItems = batch.length;
  if (false) {
    if (!navigator.onLine)
      return;
  }
  if (!url || !renderItems || !apiKey)
    return;
  try {
    const components = _Object.create(_null);
    metadataLookup.forEach((value, key) => {
      components[key] = {
        i: value.i,
        $: value.$
      };
    });
    const date = Date.now();
    const newInteractions = new _Array(interactions.length);
    for (let i = 0, len = interactions.length; i < len; i++) {
      const interaction = interactions[i];
      let loc = _null;
      let key = interaction.k;
      if (key) {
        const parts = key.split(".");
        loc = parts[2] || _null;
        if (loc)
          key = parts[0] + "." + parts[1];
      }
      newInteractions[i] = {
        n: interaction.n,
        t: interaction.t,
        l: Number(loc),
        d: date - interaction.d,
        k: interaction.k
      };
    }
    const payload = {
      batch,
      interactions: newInteractions,
      components,
      session,
      buildId,
      apiKey,
      version: VERSION,
      react: React2.version || UNKNOWN,
      geo: void 0,
      date
    };
    interactions = [];
    currentId = _null;
    currentIndex = -1;
    const _batch = false ? [] : [...batch];
    transport(url, payload).then(() => {
      if (true) {
        console.log(`[Million Lint] Ingested ${renderItems} events`, _batch);
        void compress(
          JSON.stringify(payload, (_key, value) => {
            if (value != null && value !== false) {
              if (typeof value === "number") {
                return ~~value;
              }
              return value;
            }
          })
        ).then((compressed) => {
          bytes += compressed.byteLength;
          items += renderItems;
        });
      }
    }).catch(() => {
    });
  } catch (_err) {
  }
  _setTimeout(reset, 0);
};
var reset = () => {
  batch.length = 0;
  batchIndexLookup.clear();
};
var registerMetadata = (key, size, reference) => {
  if (isSSR)
    return;
  if (reference && !(FLAG in reference)) {
    reference[FLAG] = key;
  }
  if (_mapHas.call(metadataLookup, key))
    return;
  _mapSet.call(metadataLookup, key, {
    i: 0,
    c: size,
    n: false
  });
};
var createPerformanceObservers = () => {
  if (typeof PerformanceObserver !== "function")
    return;
  const fcpObserver = new PerformanceObserver((list) => {
    const entries = list.getEntries();
    for (let i = 0, len = entries.length; i < len; i++) {
      const entry = entries[i];
      if (entry.name === "first-contentful-paint") {
        interactions.push({
          n: "FCP",
          t: ~~entry.startTime,
          d: Date.now(),
          k: _null
        });
      }
    }
  });
  fcpObserver.observe({ type: "paint", buffered: true });
  const lcpObserver = new PerformanceObserver((list) => {
    const entries = list.getEntries();
    let maxStartTime = 0;
    for (let i = 0, len = entries.length; i < len; i++) {
      const entry = entries[i];
      if (maxStartTime < entry.startTime)
        maxStartTime = entry.startTime;
    }
    interactions.push({
      n: "LCP",
      t: ~~maxStartTime,
      d: Date.now(),
      k: _null
    });
  });
  lcpObserver.observe({ type: "largest-contentful-paint", buffered: true });
  const clsObserver = new PerformanceObserver((list) => {
    const entries = list.getEntries();
    for (let i = 0, len = entries.length; i < len; i++) {
      const entry = entries[i];
      interactions.push({
        n: "CLS",
        // @ts-expect-error - PerformanceObserverEntry types are wrong
        t: entry.value,
        d: Date.now(),
        k: _null
      });
    }
  });
  clsObserver.observe({ type: "layout-shift", buffered: true });
  const inpObserver = new PerformanceObserver((list) => {
    const entries = list.getEntries();
    let maxEntry = _null;
    for (let i = 0, len = entries.length; i < len; i++) {
      const entry = entries[i];
      if (!maxEntry || entry.duration >= maxEntry.duration) {
        maxEntry = entry;
      }
    }
    if (!maxEntry)
      return;
    const id = maxEntry.interactionId;
    if (currentId !== id) {
      let key = _null;
      let target = maxEntry.target;
      while (target) {
        if (target[FLAG]) {
          key = target[FLAG];
          if (!maxEntry.target[FLAG]) {
            maxEntry.target[FLAG] = key;
          }
          break;
        }
        target = target.parentNode;
      }
      currentId = id;
      currentIndex = interactions.push({
        n: maxEntry.name,
        t: maxEntry.duration,
        d: Date.now(),
        k: key
      }) - 1;
    }
  });
  inpObserver.observe({
    type: "event",
    buffered: true
  });
};
var init = (options) => {
  if (isSSR)
    return;
  _window[FLAG] = true;
  url = options?.url || url || ENDPOINT;
  buildId ||= options?.id;
  apiKey = options?.apiKey;
  if (inited)
    return;
  inited = true;
  if (true) {
    try {
      void fetch(`${url}/reset`, { mode: "no-cors" }).then(() => {
      }).catch(() => {
      });
    } catch (_err) {
    }
    console.log(`[Million Lint] Initialized with ${url}`);
  }
  createPerformanceObservers();
  const lazyFlush = () => onIdle(flush);
  onHidden(lazyFlush);
  const debouncedLazyFlush = debounce(lazyFlush, FLUSH_TIMEOUT);
  const checkExpiry = debounce(() => {
    session = getSession();
  }, SESSION_EXPIRE_TIMEOUT);
  onRender = () => {
    debouncedLazyFlush();
    checkExpiry();
    if (true) {
      const DEV = window[`${FLAG}DEV_`];
      if (DEV) {
        DEV.startDevtools();
      }
    }
  };
};
if (true) {
  (() => {
    if (isSSR)
      return;
    const DEV = {
      batch,
      flush,
      metadataLookup,
      session,
      inited,
      buildId,
      apiKey,
      url,
      FLAG,
      interactions
    };
    let lagRadarEl = null;
    function lagRadar(config = {}) {
      const {
        frames = 50,
        // number of frames to draw, more = worse performance
        speed = 17e-4,
        // how fast the sweep moves (rads per ms)
        size = 300,
        // outer frame px
        inset = 3,
        // circle inset px
        parent = document.body
        // DOM node to attach to
      } = config;
      const svgns = "http://www.w3.org/2000/svg";
      const styles = document.createTextNode(`
        .lagRadar-sweep > * {
          shape-rendering: crispEdges;
        }
        .lagRadar-face {
          fill: transparent;
        }
        .lagRadar-hand {
          stroke-width: 4px;
          stroke-linecap: round;
        }
        @keyframes anya-pulse {
          0%, 100% {
            opacity: 1;
          }
          50% {
            opacity: .5;
          }
        }
      `);
      function $svg(tag, props = {}, children = []) {
        const el = document.createElementNS(svgns, tag);
        Object.keys(props).forEach(
          (prop) => el.setAttribute(prop, props[prop])
        );
        children.forEach((child) => el.appendChild(child));
        return el;
      }
      const PI2 = Math.PI * 2;
      const middle = size / 2;
      const radius = middle - inset;
      const $hand = $svg("path", { class: "lagRadar-hand" });
      const $arcs = new Array(frames).fill("path").map((t) => $svg(t));
      const $root = $svg(
        "svg",
        { class: "lagRadar", height: size, width: size },
        [
          $svg("style", { type: "text/css" }, [styles]),
          $svg("g", { class: "lagRadar-sweep" }, $arcs),
          $hand,
          $svg("circle", {
            class: "lagRadar-face",
            cx: middle,
            cy: middle,
            r: radius
          })
        ]
      );
      lagRadarEl = $root;
      parent.appendChild($root);
      let frame;
      let framePtr = 0;
      let last = {
        rotation: 0,
        now: Date.now(),
        tx: middle + radius,
        ty: middle
      };
      const calcHue = (() => {
        const max_hue = 120;
        const max_ms = 1e3;
        const log_f = 10;
        const mult = max_hue / Math.log(max_ms / log_f);
        return function(ms_delta) {
          return (
            // eslint-disable-next-line camelcase
            max_hue - // eslint-disable-next-line camelcase
            Math.max(0, Math.min(mult * Math.log(ms_delta / log_f), max_hue))
          );
        };
      })();
      function animate() {
        const now = Date.now();
        const rdelta = Math.min(PI2 - speed, speed * (now - last.now));
        const rotation = (last.rotation + rdelta) % PI2;
        const tx = middle + radius * Math.cos(rotation);
        const ty = middle + radius * Math.sin(rotation);
        const bigArc = rdelta < Math.PI ? "0" : "1";
        const path = `M${tx} ${ty}A${radius} ${radius} 0 ${bigArc} 0 ${last.tx} ${last.ty}L${middle} ${middle}`;
        const hue = calcHue(rdelta / speed);
        $arcs[framePtr % frames].setAttribute("d", path);
        $arcs[framePtr % frames].setAttribute("fill", `hsl(${hue}, 80%, 40%)`);
        $hand.setAttribute("d", `M${middle} ${middle}L${tx} ${ty}`);
        $hand.setAttribute("stroke", `hsl(${hue}, 80%, 60%)`);
        for (let i = 0; i < frames; i++) {
          $arcs[(frames + framePtr - i) % frames].style.fillOpacity = 1 - i / frames;
        }
        framePtr++;
        last = { now, rotation, tx, ty };
        frame = window.requestAnimationFrame(animate);
      }
      animate();
      return function destroy2() {
        if (frame) {
          window.cancelAnimationFrame(frame);
        }
        $root.remove();
      };
    }
    let interval = null;
    const indicator = document.createElement("div");
    indicator.style.position = "fixed";
    indicator.style.bottom = "10px";
    indicator.style.right = "10px";
    indicator.style.zIndex = "1000";
    indicator.style.opacity = "0";
    indicator.style.display = "flex";
    indicator.style.height = "28px";
    indicator.style.justifyContent = "center";
    indicator.style.alignItems = "center";
    indicator.style.gap = "3px";
    indicator.style.padding = "4px 12px";
    indicator.style.borderRadius = "50px";
    indicator.style.background = "#111";
    indicator.style.color = "#fff";
    indicator.style.fontSize = "12px";
    indicator.style.fontVariantNumeric = "tabular-nums";
    indicator.style.transition = "opacity 0.3s ease-in-out";
    const setConnecting = () => {
      text.nodeValue = "Connecting...";
      clearInterval(interval);
      interval = null;
      indicator.style.fontWeight = "normal";
      indicator.style.animation = "anya-pulse 2s cubic-bezier(.4,0,.6,1) infinite";
      if (lagRadarEl)
        lagRadarEl.style.display = "none";
    };
    const setFail = (source) => {
      text.nodeValue = `Failed to connect. ${source}`;
      clearInterval(interval);
      interval = null;
      indicator.style.opacity = "1";
      indicator.style.animation = "";
      indicator.style.background = "#440c13";
      indicator.style.color = "#ff575e";
      indicator.style.fontWeight = "bold";
      if (lagRadarEl)
        lagRadarEl.style.display = "none";
    };
    const text = document.createTextNode("Connecting...");
    indicator.appendChild(text);
    const destroy = lagRadar({
      frames: 30,
      // number of frames to draw, more = worse performance
      speed: 17e-4,
      // how fast the sweep moves (rads per ms)
      size: 20,
      // outer frame px
      inset: 3,
      // circle inset px
      parent: indicator
      // DOM node to attach to
    });
    indicator.onclick = () => {
      if (interval)
        clearInterval(interval);
      indicator.remove();
      destroy?.();
    };
    indicator.onmouseenter = () => {
      indicator.style.opacity = "0.3";
    };
    indicator.onmouseout = () => {
      indicator.style.opacity = "1";
    };
    document.body.appendChild(indicator);
    setTimeout(() => {
      setConnecting();
    }, 0);
    const BYTE_UNITS = ["B", "kB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"];
    const prettyBytes = (number) => {
      if (number < 1) {
        const numberString2 = number.toLocaleString("en-US");
        return numberString2 + BYTE_UNITS[0];
      }
      const exponent = Math.min(
        Math.floor(Math.log(number) / Math.log(1024)),
        BYTE_UNITS.length - 1
      );
      number /= 1024 ** exponent;
      const result = number.toPrecision(3);
      const numberString = Number(result).toLocaleString("en-US");
      const unit = BYTE_UNITS[exponent];
      return numberString + unit;
    };
    let prev = 0;
    const startDevtools = debounce(() => {
      if (!interval) {
        interval = setInterval(() => {
          requestAnimationFrame(() => {
            if (items !== prev) {
              if (lagRadarEl)
                lagRadarEl.style.display = "block";
              indicator.style.animation = "";
              indicator.style.fontWeight = "normal";
              indicator.style.opacity = "1";
              text.nodeValue = `\xD7${items} (${prettyBytes(bytes)})`;
              prev = items;
            }
          });
        }, 1);
      }
      fetch(`${url}/healthcheck`).then((res) => {
        return res.json();
      }).then((data) => {
        if (!data.ok) {
          setFail("Is your VSCode window open?");
        }
        DEV.startDevtools();
      }).catch(() => {
        setFail("Is your dev server running?");
      });
    }, 1e3);
    DEV.startDevtools = startDevtools;
    window[`${FLAG}DEV_`] = DEV;
  })();
}
